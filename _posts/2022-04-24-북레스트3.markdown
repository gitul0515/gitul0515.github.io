---
layout: post
title: '바닐라 JS로 SPA 만들기3'
date: 2022-04-24 12:12:52 +0900
categories: 프로젝트리뷰
tags: [자바스크립트, 프로젝트리뷰]
---

<img src="https://github.com/gitul0515/gitul0515.github.io/blob/main/_posts/image/bookrest/title.png?raw=true" alt="표제 이미지">

## View & Controller

이번 포스팅에서는 네비게이션과 각 화면(Home, Book, Note, Setting)을 구성하는  
View 및 Controller에 대해 구체적으로 설명하겠다.

### 1. 프로토타입 View

먼저 View의 공통 메서드를 정의한 View.js에 대해 살펴보자.  
View.js는 하나의 객체로 정의되며, 그 안에 여러 메서드를 포함하고 있다.

```Javascript
export default {
  init(element) {
    if (!element) {
      throw new Error(`element가 존재하지 않습니다.`);
    }
    this.element = element;
    return this;
  },
```

첫 번째 공통 메서드는 init이다.  
init은 element 파라미터로 html 요소를 전달받는다.  
html 요소가 존재하지 않으면 에러를 발생시킨다.  
html 요소가 존재한다면 this.element에 할당한다.

예를 들어, html 요소인 #page가 전달되는 경우,  
`this.element`에 `#page` 요소가 할당되는 식이다.

이 this.element의 역할은 매우 중요하다.  
<u>this.element는 View의 최상위 요소이며,</u>  
<u>View가 실행하는 '렌더링'의 기준점이라고 할 수 있다.</u>

View가 어떤 방식으로 렌더링을 수행하는지 간단히 설명하겠다.  
<u>View는 하위 html 요소들을 생성한 뒤에 this.element의 자식으로 추가한다.</u>
<u>만약 다른 하위 요소가 이미 존재한다면 그것을 대체한다.</u>  
이것이 View의 렌더링 동작 방식이다.

다음은 addEvent와 dispatch 메서드이다.

```Javascript
  addEvent(event, handler) {
    this.element.addEventListener(event, handler);
    return this;
  },

  dispatch(event, data) {
    const customEvent = new CustomEvent(event, { detail: data });
    this.element.dispatchEvent(customEvent);
    return this;
  },
```

addEvent는 this.element에 이벤트 핸들러를 등록한다.  
특히 커스텀 이벤트 핸들러를 등록하는 용도로 자주 사용할 것이다.  
addEvent는 this를 반환하는데, 이는 앞서 설명한 '메서드 체이닝'을 사용하기 위함이다.  
특히 addEvent는 사용 빈도가 높으므로 이러한 기법이 유용하다.

dispatch는 커스텀 이벤트 객체를 생성한 뒤, 이를 발생시킨다.  
두 번째 인수로 이벤트와 함께 전달하고 싶은 정보인 data를 전달받으며,
이것을 detail 프로퍼티를 포함하는 객체에 포함시킨다.

<p style="font-size: 1.1rem;">"왜 기존의 dispatchEvent 메서드를 두고 임의의 dispatch 메서드를 만들었을까?"</p>

=> 우선, 커스텀 이벤트를 발생시키려면 다음의 세 단계가 필요하다.

1. 커스텀 이벤트 객체 생성
2. 커스텀 이벤트 핸들러 등록 (addEvent가 담당)
3. 커스텀 이벤트 디스패치

기존의 dispatchEvent는 3번 단계를 담당하는 메서드이다.  
반면에, 내가 만든 dispatch 메서드는 1, 3번 기능을 통합하여 수행한다.  
다음의 코드를 비교해보자.

```Javascript
// dispatchEvent 사용 시
View.dispatchEvent(
  new customEvent('@click', {
    detail: { message: 'Hello' },
  })
);

// dispatch 사용 시
View.dispatch('@click', { message: 'Hello' });
```

<u>보다시피 코드가 훨씬 간결해지고 사용이 편리해졌다.</u>  
반복적인 코드(커스텀 이벤트 객체 생성)이 제거되었기 때문이다.
이것이 내가 dispatch라는 임의의 메서드를 만든 이유이다.

show는 this.element를 화면에서 보이게 한다.  
hide는 this.element를 화면에서 감춘다.  
이 둘은 화면을 전환할 때 자주 사용하는 메서드이다.
간단하므로 설명은 이 정도로 줄이겠다.

렌더 트리에서 구현하고,

반복되고

반복되는 작업은

이처럼 반복되는 작업들은 묶어서 처리하는 것이 코드 퀄리티에 도움이 된다.

이처럼 중복되는 작업들은

이는

1번 단계(커스텀 이벤트 객체 생성)

가독성이 높아지는 것을 알 수 있다.

중복된 코들르

()

커스텀 이벤트

그것은, '커스텀 이벤트 객체의 생성과 이벤트

data를 전달받는데,

왜 커스텀 이벤트를 사용하는가?

'커스텀 이벤트'를 전담하여 등록할 함수로 작성하였다.

일반 이벤트도

여기서 this.element의

특히 View의 '렌더링' 기능에 매우 중요하다.

기준점이라고도 할 수 있다.

이것이 View의 렌더링 원리이다.

View가 그리는 하위 요소들은
바로 이 this.element의 자식 요소가 된다.

View가 렌더링을 수행하는 모든 태그들이

이 과정은 왜 필요할까?
그것은 해당 View의 하위 태그들이

element라는 파라미터를 가지며, 여기에 html 요소가 전달된다.  
그리고 객체의 프로퍼티 element에 전달받은 element를 할당한다.

View.element를

active this를 반환하고 종료한다.

(미완성입니다.)

다른 모든 View 객체들은 이 View.js의 객체를 프로토타입으로 상속받는다.

### 2.

## 참고자료
