I"q<p><img src="https://github.com/gitul0515/gitul0515.github.io/blob/main/_posts/image/TIL.png?raw=true" alt="TIL 이미지" /></p>

<h3 id="자료구조--알고리즘">자료구조 &amp; 알고리즘</h3>
<h4 id="1-기본">1. 기본</h4>
<ul>
  <li>자료구조와 알고리즘이 반드시 필요한 순간이 온다.</li>
  <li>선형 구조: 한 원소 뒤에 하나의 원소  <br />
비선형 구조: 원소 간 다대다 관계  <br />
<br />
    <h4 id="2-배열">2. 배열</h4>
  </li>
  <li>탐색 O(1), 삽입 O(n), 삭제 O(n)<br />
<strong>삽입</strong>과 <strong>삭제</strong>가 빈번하다면 배열 사용을 권장하지 않는다.<br />
<br /></li>
  <li>자바스크립트의 배열
    <ul>
      <li>동적으로 크기가 변화</li>
      <li>해쉬맵(HashMap)과 유사</li>
      <li><strong>length가 내부적으로 관리되는 객체</strong></li>
      <li><strong>인덱스로 문자열, 불리언도 가능</strong>  <br />
이 경우 배열의 length가 변화하지 않는다. <br />
<br />
        <pre><code class="language-Javascript">const array = [1, 2, 3, 4, 5];
array['key'] = 'value';
array[true] = true;
console.log(array.length) // 5
</code></pre>
        <p>이는 안 좋은 사용방법이다.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-연결-리스트">3. 연결 리스트</h4>
<ul>
  <li>탐색 O(n), 삽입 O(1), 삭제 O(1). 
다만 삽입/삭제하려면 원하는 노드를 탐색해야 하므로, 
현실적으로 삽입 O(n + 1), 삭제 O(n + 1)이다.<br />
<br /></li>
  <li>배열과 달리, 메모리가 비순차적으로 저장된다.</li>
</ul>

<h4 id="4-기타">4. 기타</h4>
<ul>
  <li>for…of 문은 중간에 탈출할 수 있다. (break나 return을 사용하여)</li>
  <li>value만이 필요하다면 for…of 문을 사용하라.</li>
</ul>

<h3 id="참고자료">참고자료</h3>
<p>데브코스 2일차 강의</p>
:ET